// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"strings"

	"gorm.io/gorm"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"talkee/core"
)

func newComment(db *gorm.DB, opts ...gen.DOOption) comment {
	_comment := comment{}

	_comment.commentDo.UseDB(db, opts...)
	_comment.commentDo.UseModel(&core.Comment{})

	tableName := _comment.commentDo.TableName()
	_comment.ALL = field.NewAsterisk(tableName)
	_comment.ID = field.NewUint64(tableName, "id")
	_comment.UserID = field.NewUint64(tableName, "user_id")
	_comment.SiteID = field.NewUint64(tableName, "site_id")
	_comment.Slug = field.NewString(tableName, "slug")
	_comment.FavorCount = field.NewUint64(tableName, "favor_count")
	_comment.ReplyCount = field.NewUint64(tableName, "reply_count")
	_comment.ArweaveTxHash = field.NewString(tableName, "arweave_tx_hash")
	_comment.Content = field.NewString(tableName, "content")
	_comment.CreatedAt = field.NewTime(tableName, "created_at")
	_comment.UpdatedAt = field.NewTime(tableName, "updated_at")
	_comment.DeletedAt = field.NewTime(tableName, "deleted_at")

	_comment.fillFieldMap()

	return _comment
}

type comment struct {
	commentDo

	ALL           field.Asterisk
	ID            field.Uint64
	UserID        field.Uint64
	SiteID        field.Uint64
	Slug          field.String
	FavorCount    field.Uint64
	ReplyCount    field.Uint64
	ArweaveTxHash field.String
	Content       field.String
	CreatedAt     field.Time
	UpdatedAt     field.Time
	DeletedAt     field.Time

	fieldMap map[string]field.Expr
}

func (c comment) Table(newTableName string) *comment {
	c.commentDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c comment) As(alias string) *comment {
	c.commentDo.DO = *(c.commentDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *comment) updateTableName(table string) *comment {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewUint64(table, "id")
	c.UserID = field.NewUint64(table, "user_id")
	c.SiteID = field.NewUint64(table, "site_id")
	c.Slug = field.NewString(table, "slug")
	c.FavorCount = field.NewUint64(table, "favor_count")
	c.ReplyCount = field.NewUint64(table, "reply_count")
	c.ArweaveTxHash = field.NewString(table, "arweave_tx_hash")
	c.Content = field.NewString(table, "content")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.DeletedAt = field.NewTime(table, "deleted_at")

	c.fillFieldMap()

	return c
}

func (c *comment) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *comment) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 11)
	c.fieldMap["id"] = c.ID
	c.fieldMap["user_id"] = c.UserID
	c.fieldMap["site_id"] = c.SiteID
	c.fieldMap["slug"] = c.Slug
	c.fieldMap["favor_count"] = c.FavorCount
	c.fieldMap["reply_count"] = c.ReplyCount
	c.fieldMap["arweave_tx_hash"] = c.ArweaveTxHash
	c.fieldMap["content"] = c.Content
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["deleted_at"] = c.DeletedAt
}

func (c comment) clone(db *gorm.DB) comment {
	c.commentDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c comment) replaceDB(db *gorm.DB) comment {
	c.commentDo.ReplaceDB(db)
	return c
}

type commentDo struct{ gen.DO }

type ICommentDo interface {
	WithContext(ctx context.Context) ICommentDo

	GetComments(ctx context.Context, siteID uint64, slug string, offset uint64, limit uint64, orderBy string, order string) (result []*core.Comment, err error)
	GetComment(ctx context.Context, id uint64) (result *core.Comment, err error)
	CreateComment(ctx context.Context, userID uint64, siteID uint64, slug string, content string) (result uint64, err error)
	UpdateCommentTxHash(ctx context.Context, id uint64, txHash string) (err error)
	CountComments(ctx context.Context, siteID uint64, slug string) (result uint64, err error)
	GetAllCommentsBySiteSlug(ctx context.Context, siteID uint64, slug string) (result []*core.Comment, err error)
	FindArweaveSyncList(ctx context.Context, limit uint64) (result []*core.ArweaveSyncListItem, err error)
	FavComment(ctx context.Context, id uint64, userID uint64, fav bool) (err error)
	IncCommentReplyCount(ctx context.Context, id uint64) (err error)
}

// SELECT
//
//	*
//
// FROM "comments"
// WHERE
//
//	"comments"."site_id" = @siteID
//	AND "comments"."slug" = @slug
//	AND "comments"."deleted_at" IS NULL
//
// {{if orderBy == "favor_count"}}
//
//	ORDER BY "favor_count" {{if order == "DESC" }} DESC {{else}} ASC {{end}}
//
// {{else}}
//
//	ORDER BY "created_at" {{if order == "DESC" }} DESC {{else}} ASC {{end}}
//
// {{end}}
// OFFSET @offset
// LIMIT @limit;
func (c commentDo) GetComments(ctx context.Context, siteID uint64, slug string, offset uint64, limit uint64, orderBy string, order string) (result []*core.Comment, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, siteID)
	params = append(params, slug)
	generateSQL.WriteString("SELECT * FROM \"comments\" WHERE \"comments\".\"site_id\" = ? AND \"comments\".\"slug\" = ? AND \"comments\".\"deleted_at\" IS NULL ")
	if orderBy == "favor_count" {
		generateSQL.WriteString("ORDER BY \"favor_count\" ")
		if order == "DESC" {
			generateSQL.WriteString("DESC ")
		} else {
			generateSQL.WriteString("ASC ")
		}
	} else {
		generateSQL.WriteString("ORDER BY \"created_at\" ")
		if order == "DESC" {
			generateSQL.WriteString("DESC ")
		} else {
			generateSQL.WriteString("ASC ")
		}
	}
	params = append(params, offset)
	params = append(params, limit)
	generateSQL.WriteString("OFFSET ? LIMIT ?; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
// *
// FROM "comments"
// WHERE
//
//	"comments"."id" = @id
//	AND "comments"."deleted_at" IS NULL
//
// LIMIT 1;
func (c commentDo) GetComment(ctx context.Context, id uint64) (result *core.Comment, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("SELECT * FROM \"comments\" WHERE \"comments\".\"id\" = ? AND \"comments\".\"deleted_at\" IS NULL LIMIT 1; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// INSERT INTO "comments"
//
//	(
//		"user_id",
//		"site_id",
//		"slug",
//		"content",
//		"created_at", "updated_at"
//	)
//
// VALUES
//
//	(
//		@userID,
//		@siteID,
//		@slug,
//		@content,
//		NOW(), NOW()
//	)
//
// RETURNING id;
func (c commentDo) CreateComment(ctx context.Context, userID uint64, siteID uint64, slug string, content string) (result uint64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, userID)
	params = append(params, siteID)
	params = append(params, slug)
	params = append(params, content)
	generateSQL.WriteString("INSERT INTO \"comments\" ( \"user_id\", \"site_id\", \"slug\", \"content\", \"created_at\", \"updated_at\" ) VALUES ( ?, ?, ?, ?, NOW(), NOW() ) RETURNING id; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// UPDATE
//
//	"comments"
//
// SET
// "arweave_tx_hash" = @txHash,
//
//	"updated_at" = NOW()
//
// WHERE
//
//	"id" = @id AND "deleted_at" IS NULL;
//
// ;
func (c commentDo) UpdateCommentTxHash(ctx context.Context, id uint64, txHash string) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, txHash)
	params = append(params, id)
	generateSQL.WriteString("UPDATE \"comments\" SET \"arweave_tx_hash\" = ?, \"updated_at\" = NOW() WHERE \"id\" = ? AND \"deleted_at\" IS NULL; ; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
//
//	COUNT("id")
//
// FROM "comments"
// WHERE
// {{if siteID != 0}}
//
//	"site_id"=@siteID AND "slug"=@slug AND
//
// {{end}}
// "deleted_at" IS NULL;
func (c commentDo) CountComments(ctx context.Context, siteID uint64, slug string) (result uint64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("SELECT COUNT(\"id\") FROM \"comments\" WHERE ")
	if siteID != 0 {
		params = append(params, siteID)
		params = append(params, slug)
		generateSQL.WriteString("\"site_id\"=? AND \"slug\"=? AND ")
	}
	generateSQL.WriteString("\"deleted_at\" IS NULL; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
//
//	"id",
//	"user_id",
//	"site_id",
//	"slug",
//	"favor_count"
//
// FROM "comments"
// WHERE
//
//	"site_id" = @siteID
//
// AND
//
//	"slug" = @slug
//
// AND "deleted_at" IS NULL;
func (c commentDo) GetAllCommentsBySiteSlug(ctx context.Context, siteID uint64, slug string) (result []*core.Comment, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, siteID)
	params = append(params, slug)
	generateSQL.WriteString("SELECT \"id\", \"user_id\", \"site_id\", \"slug\", \"favor_count\" FROM \"comments\" WHERE \"site_id\" = ? AND \"slug\" = ? AND \"deleted_at\" IS NULL; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
//
//	"comments"."id",
//	"comments"."user_id",
//	"comments"."site_id",
//	"comments"."slug",
//	"comments"."favor_count", "reply_count",
//	"comments"."arweave_tx_hash",
//	"comments"."content",
//	"users"."mixin_user_id",
//	"users"."mixin_identity_number",
//	"users"."full_name",
//	"users"."avatar_url",
//	"users"."mvm_public_key",
//	"comments"."created_at",
//	"comments"."updated_at"
//
// FROM "comments"
// INNER JOIN "users" ON "comments"."user_id" = "users"."id"
// WHERE
//
//	"comments"."site_id" in (
//		select "id" FROM "sites" WHERE  "use_arweave" = true
//	)
//	AND  ("comments"."arweave_tx_hash" is NULL OR "comments"."arweave_tx_hash" = '')
//	AND "comments"."deleted_at" IS NULL
//
// ORDER BY "comments"."created_at" asc
// LIMIT @limit
// ;
func (c commentDo) FindArweaveSyncList(ctx context.Context, limit uint64) (result []*core.ArweaveSyncListItem, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, limit)
	generateSQL.WriteString("SELECT \"comments\".\"id\", \"comments\".\"user_id\", \"comments\".\"site_id\", \"comments\".\"slug\", \"comments\".\"favor_count\", \"reply_count\", \"comments\".\"arweave_tx_hash\", \"comments\".\"content\", \"users\".\"mixin_user_id\", \"users\".\"mixin_identity_number\", \"users\".\"full_name\", \"users\".\"avatar_url\", \"users\".\"mvm_public_key\", \"comments\".\"created_at\", \"comments\".\"updated_at\" FROM \"comments\" INNER JOIN \"users\" ON \"comments\".\"user_id\" = \"users\".\"id\" WHERE \"comments\".\"site_id\" in ( select \"id\" FROM \"sites\" WHERE \"use_arweave\" = true ) AND (\"comments\".\"arweave_tx_hash\" is NULL OR \"comments\".\"arweave_tx_hash\" = '') AND \"comments\".\"deleted_at\" IS NULL ORDER BY \"comments\".\"created_at\" asc LIMIT ? ; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// UPDATE "comments"
// SET
//
//	{{if fav}}"favor_count" = "favor_count" + 1 {{else}}"favor_count" = "favor_count" - 1{{end}},
//	"updated_at" = NOW()
//
// WHERE
//
//	"id" = @id AND "deleted_at" IS NULL;
func (c commentDo) FavComment(ctx context.Context, id uint64, userID uint64, fav bool) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("UPDATE \"comments\" SET ")
	if fav {
		generateSQL.WriteString("\"favor_count\" = \"favor_count\" + 1 ")
	} else {
		generateSQL.WriteString("\"favor_count\" = \"favor_count\" - 1 ")
	}
	params = append(params, id)
	generateSQL.WriteString(", \"updated_at\" = NOW() WHERE \"id\" = ? AND \"deleted_at\" IS NULL; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// UPDATE
//
//	"comments"
//
// SET
//
//	"reply_count" = "reply_count" + 1,
//	"updated_at" = NOW()
//
// WHERE
//
//	"id" = @id AND "deleted_at" IS NULL;
func (c commentDo) IncCommentReplyCount(ctx context.Context, id uint64) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("UPDATE \"comments\" SET \"reply_count\" = \"reply_count\" + 1, \"updated_at\" = NOW() WHERE \"id\" = ? AND \"deleted_at\" IS NULL; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (c commentDo) WithContext(ctx context.Context) ICommentDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c *commentDo) withDO(do gen.Dao) *commentDo {
	c.DO = *do.(*gen.DO)
	return c
}
