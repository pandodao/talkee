// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"strings"

	"gorm.io/gorm"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"talkee/core"
)

func newCommentFavourite(db *gorm.DB, opts ...gen.DOOption) commentFavourite {
	_commentFavourite := commentFavourite{}

	_commentFavourite.commentFavouriteDo.UseDB(db, opts...)
	_commentFavourite.commentFavouriteDo.UseModel(&core.CommentFavourite{})

	tableName := _commentFavourite.commentFavouriteDo.TableName()
	_commentFavourite.ALL = field.NewAsterisk(tableName)
	_commentFavourite.ID = field.NewUint64(tableName, "id")
	_commentFavourite.UserID = field.NewUint64(tableName, "user_id")
	_commentFavourite.CommentID = field.NewUint64(tableName, "comment_id")
	_commentFavourite.CreatedAt = field.NewTime(tableName, "created_at")
	_commentFavourite.UpdatedAt = field.NewTime(tableName, "updated_at")
	_commentFavourite.DeletedAt = field.NewTime(tableName, "deleted_at")

	_commentFavourite.fillFieldMap()

	return _commentFavourite
}

type commentFavourite struct {
	commentFavouriteDo

	ALL       field.Asterisk
	ID        field.Uint64
	UserID    field.Uint64
	CommentID field.Uint64
	CreatedAt field.Time
	UpdatedAt field.Time
	DeletedAt field.Time

	fieldMap map[string]field.Expr
}

func (c commentFavourite) Table(newTableName string) *commentFavourite {
	c.commentFavouriteDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c commentFavourite) As(alias string) *commentFavourite {
	c.commentFavouriteDo.DO = *(c.commentFavouriteDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *commentFavourite) updateTableName(table string) *commentFavourite {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewUint64(table, "id")
	c.UserID = field.NewUint64(table, "user_id")
	c.CommentID = field.NewUint64(table, "comment_id")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.DeletedAt = field.NewTime(table, "deleted_at")

	c.fillFieldMap()

	return c
}

func (c *commentFavourite) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *commentFavourite) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 6)
	c.fieldMap["id"] = c.ID
	c.fieldMap["user_id"] = c.UserID
	c.fieldMap["comment_id"] = c.CommentID
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["deleted_at"] = c.DeletedAt
}

func (c commentFavourite) clone(db *gorm.DB) commentFavourite {
	c.commentFavouriteDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c commentFavourite) replaceDB(db *gorm.DB) commentFavourite {
	c.commentFavouriteDo.ReplaceDB(db)
	return c
}

type commentFavouriteDo struct{ gen.DO }

type ICommentFavouriteDo interface {
	WithContext(ctx context.Context) ICommentFavouriteDo

	FindAllCommentFavourites(ctx context.Context, commentID uint64) (result []*core.CommentFavourite, err error)
	FindUserCommentFavourites(ctx context.Context, userID uint64, commentIDs []uint64) (result []*core.CommentFavourite, err error)
	CountAllFavourites(ctx context.Context) (result uint64, err error)
}

// SELECT
//
//	I
//
// FROM "favourites"
// WHERE
//
//	"comment_id" = @commentID
//
// AND
//
//	"deleted_at" is NULL
//
// ;
func (c commentFavouriteDo) FindAllCommentFavourites(ctx context.Context, commentID uint64) (result []*core.CommentFavourite, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, commentID)
	generateSQL.WriteString("SELECT I FROM \"favourites\" WHERE \"comment_id\" = ? AND \"deleted_at\" is NULL ; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
//
//	*
//
// FROM "favourites"
// WHERE
// "comment_id" IN (@commentIDs)
// AND
//
//	"user_id"=@userID
//
// AND
//
//	"deleted_at" is NULL;
func (c commentFavouriteDo) FindUserCommentFavourites(ctx context.Context, userID uint64, commentIDs []uint64) (result []*core.CommentFavourite, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, commentIDs)
	params = append(params, userID)
	generateSQL.WriteString("SELECT * FROM \"favourites\" WHERE \"comment_id\" IN (?) AND \"user_id\"=? AND \"deleted_at\" is NULL; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
//
//	count("id")
//
// FROM @@table
func (c commentFavouriteDo) CountAllFavourites(ctx context.Context) (result uint64, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("SELECT count(\"id\") FROM comment_favourites ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String()).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (c commentFavouriteDo) WithContext(ctx context.Context) ICommentFavouriteDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c *commentFavouriteDo) withDO(do gen.Dao) *commentFavouriteDo {
	c.DO = *do.(*gen.DO)
	return c
}
