// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"strings"

	"gorm.io/gorm"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"talkee/core"
)

func newReply(db *gorm.DB, opts ...gen.DOOption) reply {
	_reply := reply{}

	_reply.replyDo.UseDB(db, opts...)
	_reply.replyDo.UseModel(&core.Reply{})

	tableName := _reply.replyDo.TableName()
	_reply.ALL = field.NewAsterisk(tableName)
	_reply.ID = field.NewUint64(tableName, "id")
	_reply.UserID = field.NewUint64(tableName, "user_id")
	_reply.CommentID = field.NewString(tableName, "comment_id")
	_reply.Content = field.NewString(tableName, "content")
	_reply.CreatedAt = field.NewTime(tableName, "created_at")
	_reply.UpdatedAt = field.NewTime(tableName, "updated_at")
	_reply.DeletedAt = field.NewTime(tableName, "deleted_at")

	_reply.fillFieldMap()

	return _reply
}

type reply struct {
	replyDo

	ALL       field.Asterisk
	ID        field.Uint64
	UserID    field.Uint64
	CommentID field.String
	Content   field.String
	CreatedAt field.Time
	UpdatedAt field.Time
	DeletedAt field.Time

	fieldMap map[string]field.Expr
}

func (r reply) Table(newTableName string) *reply {
	r.replyDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r reply) As(alias string) *reply {
	r.replyDo.DO = *(r.replyDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *reply) updateTableName(table string) *reply {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewUint64(table, "id")
	r.UserID = field.NewUint64(table, "user_id")
	r.CommentID = field.NewString(table, "comment_id")
	r.Content = field.NewString(table, "content")
	r.CreatedAt = field.NewTime(table, "created_at")
	r.UpdatedAt = field.NewTime(table, "updated_at")
	r.DeletedAt = field.NewTime(table, "deleted_at")

	r.fillFieldMap()

	return r
}

func (r *reply) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *reply) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 7)
	r.fieldMap["id"] = r.ID
	r.fieldMap["user_id"] = r.UserID
	r.fieldMap["comment_id"] = r.CommentID
	r.fieldMap["content"] = r.Content
	r.fieldMap["created_at"] = r.CreatedAt
	r.fieldMap["updated_at"] = r.UpdatedAt
	r.fieldMap["deleted_at"] = r.DeletedAt
}

func (r reply) clone(db *gorm.DB) reply {
	r.replyDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r reply) replaceDB(db *gorm.DB) reply {
	r.replyDo.ReplaceDB(db)
	return r
}

type replyDo struct{ gen.DO }

type IReplyDo interface {
	WithContext(ctx context.Context) IReplyDo

	GetReplies(ctx context.Context, commentID uint64, offset uint64, limit uint64) (result []*core.Reply, err error)
	GetReply(ctx context.Context, replyID uint64) (result *core.Reply, err error)
	CountReplies(ctx context.Context, commentID uint64) (result uint64, err error)
	CreateReply(ctx context.Context, userID uint64, commentID uint64, content string) (result uint64, err error)
}

// SELECT
//
//	*
//
// FROM "replies"
// WHERE
//
//	"replies"."comment_id" = @commentID
//	AND "deleted_at" IS NULL
//
// ORDER BY "replies"."created_at" DESC
// OFFSET @offset
// LIMIT @limit;
func (r replyDo) GetReplies(ctx context.Context, commentID uint64, offset uint64, limit uint64) (result []*core.Reply, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, commentID)
	params = append(params, offset)
	params = append(params, limit)
	generateSQL.WriteString("SELECT * FROM \"replies\" WHERE \"replies\".\"comment_id\" = ? AND \"deleted_at\" IS NULL ORDER BY \"replies\".\"created_at\" DESC OFFSET ? LIMIT ?; ")

	var executeSQL *gorm.DB
	executeSQL = r.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
//
//	*
//
// FROM "replies"
// WHERE
//
//	"replies"."id" = @replyID
//	AND "replies"."deleted_at" IS NULL
//
// LIMIT 1;
func (r replyDo) GetReply(ctx context.Context, replyID uint64) (result *core.Reply, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, replyID)
	generateSQL.WriteString("SELECT * FROM \"replies\" WHERE \"replies\".\"id\" = ? AND \"replies\".\"deleted_at\" IS NULL LIMIT 1; ")

	var executeSQL *gorm.DB
	executeSQL = r.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT
//
//	COUNT("id")
//
// FROM "replies"
// WHERE
// "comment_id" = @commentID
//
//	AND "deleted_at" IS NULL;
func (r replyDo) CountReplies(ctx context.Context, commentID uint64) (result uint64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, commentID)
	generateSQL.WriteString("SELECT COUNT(\"id\") FROM \"replies\" WHERE \"comment_id\" = ? AND \"deleted_at\" IS NULL; ")

	var executeSQL *gorm.DB
	executeSQL = r.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// INSERT INTO "replies"
//
//	(
//		"user_id",
//		"comment_id",
//		"content",
//		"created_at", "updated_at"
//	)
//
// VALUES
//
//	(
//		@userID,
//		@commentID,
//		@content,
//		NOW(), NOW()
//	)
//
// RETURNING id;
func (r replyDo) CreateReply(ctx context.Context, userID uint64, commentID uint64, content string) (result uint64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, userID)
	params = append(params, commentID)
	params = append(params, content)
	generateSQL.WriteString("INSERT INTO \"replies\" ( \"user_id\", \"comment_id\", \"content\", \"created_at\", \"updated_at\" ) VALUES ( ?, ?, ?, NOW(), NOW() ) RETURNING id; ")

	var executeSQL *gorm.DB
	executeSQL = r.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (r replyDo) WithContext(ctx context.Context) IReplyDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r *replyDo) withDO(do gen.Dao) *replyDo {
	r.DO = *do.(*gen.DO)
	return r
}
